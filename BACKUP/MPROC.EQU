*******************
*MASTER EQUATE FILE
*.Last mod - 9/23/91 16:20
*******************

* GLOBAL VARIABLES

	.GLOBL	KILALL,GETPRC,KILL,PINIT,SUCIDE,PRCSLP,PRCDSP,PRCLSP,EXISTP
	.GLOBL	RAND,TIMER,OVERLOAD,ACTIVE,FREE,PRCSTR,PEXIST
	.GLOBL	SNDRES,SNDRESP,ONESND,SNDLD,SNDSND,CKSNDPRI,QSNDRST
	.GLOBL	GETA11,GETA10,GETA9,GETA8,XFERPROC
	.GLOBL	PUTA11,PUTA10,PUTA9,PUTA8,PUTA7
	.globl	KIL1C,KILALLN,KOP_1C,KOP_ALL

* PROCESS DATA STRUCTURE
* NOTE: MAKE SURE THIS IS EVENLY DIVISIBLE BY 32
*STRUCT PROC
PLINK	.SET    0	        ;LINK TO NEXT 32 BITS
PROCID	.SET	20H	        ;UHW PROCESS ID 16 BITS
PTIME	.SET    30H	        ;UHW SLEEP TIME X 16MSEC 16 BITS
PSPTR	.SET    40H	        ;UHL PROCESS STACK POINTER 32 BITS
PA11	.SET	60H		;UHL	REGISTERS SAVED
PA10	.SET	80H		;UHL
PA9	.SET    0A0H		;UHL
PA8	.SET	0C0H		;UHL
PWAKE	.SET	0E0H		;UHL
PDATA	.SET    100H	        ;PROCESS DATA STORE
;PSDATA	.SET    2A0H            ;PROCESS STACK DATA (PC, A8-A11)
PSDATA	.SET    3D0H            ;PROCESS STACK DATA (PC, A8-A11)
PRCSIZ	.SET    5A0H            ;END OF DATA STRUCTURE
*ENDSTRUCT

NPROC	.SET    240	        ;NUMBER OF PROCESSES ;240 FOR SMASH

*GSP MACROS

*SUBTRACT REGISTER FROM MEMORY
*	SUBRM	REG,ADDR,FIELD SIZE
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
SUBRM	$MACRO	P1,P2,P3
	MOVE	:P2:,A14,:P3:
	SUB	:P1:,A14
	MOVE	A14,:P2:,:P3:
	$ENDM

*ADD REGISTER TO MEMORY
*	ADDRM	REG,ADDR,FIELD SIZE
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
ADDRM	$MACRO	P1,P2,P3
	MOVE	:P2:,A14,:P3:
	ADD	:P1:,A14
	MOVE	A14,:P2:,:P3:
	$ENDM

*INCREMENT LOCATION
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
**
INCW	$MACRO	P1
	MOVE	:P1:,A14
	INC	A14
	MOVE	A14,:P1:
	$ENDM

*DECREMENT WORD
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY

DECW	$MACRO	P1
	MOVE	:P1:,A14
	DEC	A14
	MOVE	A14,:P1:
	$ENDM

*INCREMENT MEMORY
*	INCM	ADDR,FIELD SIZE
*A14 DESTROYED

INCM	$MACRO	P1,P2
	MOVE	:P1:,A14,:P2:
	INC	A14
	MOVE	A14,:P1:,:P2:
	$ENDM

*DECREMENT MEMORY
*	DECM	ADDR,FIELD SIZE
*A14 DESTROYED

DECM	$MACRO	P1,P2
	MOVE	:P1:,A14,:P2:
	DEC	A14
	MOVE	A14,:P1:,:P2:
	$ENDM

*SUBTRACT MEMORY
*	SUBM	ADDR,REG,FIELD SIZE
*SUBTRACTS ADDRESS FROM REGISTER
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY

SUBM	$MACRO	P1,P2,P3
	MOVE	:P1:,A14,:P3:
	SUB	A14,:P2:
	$ENDM

*ADD MEMORY
*	ADDM	ADDR,REG,FIELD SIZE
*ADDS ADDRESS FROM REGISTER
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY

ADDM	$MACRO	P1,P2,P3
	MOVE	:P1:,A14,:P3:
	ADD	A14,:P2:
	$ENDM

*NEGATE MEMORY
*	NEGM	ADDR,FIELD SIZE
*NEGATES ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY

NEGM	$MACRO	P1,P2
	MOVE	:P1:,A14,:P2:
	NEG	A14
	MOVE	A14,:P1:,:P2:
	$ENDM

*COMPARE MEMORY
*	CMPM	ADDR,REG,FIELD SIZE
*COMPARES ADDRESS TO REGISTER
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY

CMPM	$MACRO	P1,P2,P3
	MOVE	:P1:,A14,:P3:
	CMP	A14,:P2:
	$ENDM

*CLEAR MEMORY
*	CLRM	ADDR,FIELD SIZE
*CLEARS ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY

CLRM	$MACRO	P1,P2
	CLR	A14
	MOVE	A14,:P1:,:P2:
	$ENDM

*COMPLEMENT MEMORY
*	COMM	ADDR,FIELD SIZE
*COMPLEMENTS ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY

COMM	$MACRO	P1,P2
	MOVE	:P1:,A14,:P2:
	NOT	A14
	MOVE	A14,:P1:,:P2:
	$ENDM

*SHIFT LEFT MEMORY
*	SLLM	SHIFT COUNT,ADDR,FIELD SIZE
*SHIFTS ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY

SLLM	$MACRO	P1,P2,P3
	MOVE	:P2:,A14,:P3:
	SLL	:P1:,A14
	MOVE	A14,:P2:,:P3:
	$ENDM

*SHIFT RIGHT ARITHMETIC MEMORY
*	SRAM	SHIFT COUNT,ADDR,FIELD SIZE
*SHIFTS ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY

SRAM	$MACRO	P1,P2,P3
	MOVE	:P2:,A14,:P3:
	SEXT	A14,:P3:
	SRA	:P1:,A14
	MOVE	A14,:P2:,:P3:
	$ENDM

*SHIFT RIGHT LOGICAL MEMORY
*	SRLM	SHIFT COUNT,ADDR,FIELD SIZE
*SHIFTS ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY

SRLM	$MACRO	P1,P2,P3
	MOVE	:P2:,A14,:P3:
	ZEXT 	A14,:P3:
	SRL	:P1:,A14
	MOVE	A14,:P2:,:P3:
	$ENDM

*BIT SET
*	BSET	BIT# 0-31(KONSTANT OR REGISTER),REGISTER TO SET BIT IN
* NOTE: A14 IS DESTROYED, 'A' FILE REGISTERS ONLY

BSET	$MACRO	P1,R1
	MOVK	1,A14
	SLL	:P1:,A14
	OR	A14,:R1:
	$ENDM


*BIT CLR
*	BCLR	BIT# 0-31(KONSTANT OR REGISTER),REGISTER TO CLR BIT IN
* NOTE: A14 IS DESTROYED, 'A' FILE REGISTERS ONLY

BCLR	$MACRO	P1,R1
	MOVK	1,A14
	SLL	:P1:,A14
	ANDN	A14,:R1:
	$ENDM

*SET THE Z BIT
*	SETZ
* STATUS BITS:
*		N Unaffected
*		C Unaffected
*		Z 1
*		V Unaffected
* NOTE: A14 IS CLEARED

SETZ	$MACRO
	CLR	A14
	$ENDM

*CLR THE Z BIT
*	CLRZ
* STATUS BITS:
*		N Unaffected
*		C Unaffected
*		Z 0
*		V Unaffected
* NOTE: A14 IS SET TO 1

CLRZ	$MACRO
	CLR	A14
	NOT	A14
	$ENDM

*PROCESS SLEEP CONSTANT
*A=SLEEP TIME CONSTANT 1-FFFF LOADED INTO A0
*RET ADDR ON STACK

SLEEP	$macro	A
	movi	:A:,a0
	calla	PRCSLP
	$endm

SLEEPK	$macro	A
	movk	:A:,a0
	calla	PRCSLP
	$endm

*PROCESS SLEEP REGISTER
*REG1=REGISTER THAT CONTAINS SLEEP TIME 1-FFFF LOADED INTO A0
*RET ADDR ON STACK

SLEEPR	$MACRO	REG1
	MOVE	:REG1:,A0
	CALLA	PRCSLP
	$ENDM

*PROCESS LOOP SLEEP
*P1=SLEEP TIME --0A0H, P2=WAKEUP ADDR--0A7H

SLOOP	$MACRO	P1,P2
	$IF	P1 < 33
	MOVK	:P1:,A0
	$ELSE	
	MOVI	:P1:,A0
	$ENDIF
	MOVI	:P2:,A7,L
	JAUC	PRCLSP
	$ENDM
	
*PROCESS LOOP SLEEP REGISTER
*P1=REGISTER CONTAINING SLEEP TIME 1-FFFF, P2 =WAKEUP ADDR--0A7H

SLOOPR	$MACRO	P1,P2
	MOVE	:P1:,A0
	MOVI	:P2:,A7,L
	JAUC	PRCLSP
	$ENDM

*PROCESS CREATION MACRO
*P1=ID--0A1H, P2=PC--0A7H

CREATE	$macro	p1,p2
	movi	:p1:,a1
	movi	:p2:,a7,L
	calla	GETPRC
	$endm

*PROCESS CREATION MACRO
*A=PC--0A7H
CREATE0	$macro	A
	clr	a1
	movi	:A:,a7,L
	calla	GETPRC
	$endm

*KILL PROCESS(ES)
*P1=ID--0A0H,P2=MASK--0A1H

KILLIT	$MACRO	P1,P2
	MOVI	:P1:,A0
	MOVI	:P2:,A1
	CALLA	KILALL
	$ENDM

*CALL IT QUITS

DIE	$MACRO
	JAUC	SUCIDE
	$ENDM

*PROCESS JUMP SUBROUTINE
*P1=ADDRESS OF SLEEPING PROCESS
*A7 IS USED FOR PC STORAGE

JSRP	$MACRO	P1
	GETPC	A7
	ADDI    060h,A7
	MOVE	A7,-*A12,L	;PUSH RET ADDR
	JAUC	:P1:
	$ENDM

*PROCESS JUMP SUBROUTINE ON REGISTER
*R1=REGISTER CONTAINING ADDRESS OF SLEEPING PROCESS
*A7 IS USED FOR PC STORAGE

JSRPR	$MACRO	R1
	GETPC	A7
	ADDI    040h,A7
	MOVE	A7,-*A12,L	;PUSH RET ADDR
	JUMP	:R1:
	$ENDM

*RETURN FROM SLEEPING SUBROUTINE
*A7 IS USED FOR PC STORAGE
*STATUS REGISTER IS NOT AFFECTED
	
RETP	$MACRO	
	MMFM	A12,A7		;PULL RETURN ADDR, W/O ZAPPING STAT
	EXGPC	A7
	$ENDM

*FIND MATCHING PROCESS(ES), BRANCH IF ONE WAS FOUND
*P1=ID--0A0H,P2=MASK--0A1H,P3=BRANCH LABEL
MATCHP	$MACRO	P1,P2,P3
	MOVI	:P1:,A0
	MOVI	:P2:,A1
	CALLA	EXISTP
	JANZ	:P3:
	$ENDM

*FIND MATCHING PROCESS(ES), BRANCH IF NONE WERE FOUND
*P1=ID--0A0H,P2=MASK--0A1H,P3=BRANCH LABEL
NOMATCHP $MACRO	P1,P2,P3
	 MOVI	:P1:,A0
	 MOVI	:P2:,A1
	 CALLA	EXISTP
	 JAZ	:P3:
	 $ENDM

*PUSH REGISTER(S) ONTO THE STACK
*USAGE: ONE OPERAND -> PUSH OP   2 OR MORE OPS -> PUSH (OP1,OP2,...,OPN)
PUSH	$MACRO	REG
	MOVE :REG:,-*SP,1
	$ENDM

*PULL REGISTER(S) OFF OF THE STACK
*USAGE: ONE REGISTER -> PULL REG   2 OR MORE REGS -> PULL (REG1,REG2,...,REGN)
PULL	$MACRO	REG
	MMFM	SP,:REG:
	$ENDM

*PUSH REGISTER ONTO THE PROCESS STACK
*USAGE: ONE OPERAND -> PUSH REG
PUSHP	$MACRO	REG
	MOVE :REG:,-*A12,L
	$ENDM

*PULL REGISTER(S) OFF OF THE PROCESS STACK
*USAGE: ONE REGISTER -> PULL REG 
PULLP	$MACRO	REG
	MMFM	A12,:REG:
	$ENDM

*PUSH LOW WORD OF REGISTER ON TO STACK
*ONE REGISTER ONLY!
*USAGE: PUSHW REG
PUSHW	$MACRO	REG
	MOVE :REG:,-*SP,0
	$ENDM

*PULL LOW WORD OF REGISTER OFF OF STACK
*ONE REGISTER ONLY!
*USAGE: PULLW REG
PULLW	$MACRO	REG
	MOVE *SP+,:REG:,0
	$ENDM

*NULL LONG WORD							 
LONGNULL:$MACRO	 
	.LONG 0								 
	$ENDM								 

*LOCKUP MACRO

LOCKUP	$MACRO
	DINT
	JRUC	$
	$ENDM
